<!DOCTYPE html>
<html lang="en">
<head>
    <title>A-Frame World Tracking Example</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script async src="https://docs.opencv.org/master/opencv.js"></script>

    <script src="js/gesture-detector.js"></script>
    <script src="js/gesture-handler.js"></script>
        <script>
    // Definizione globale di onOpenCvReady
    window.onOpenCvReady = () => {
      cv.onRuntimeInitialized = () => {
        console.log('OpenCV.js is ready.')

        // Verifica la versione di OpenCV.js
        console.log('OpenCV.js version:', cv.getBuildInformation())

        // Crea un'istanza del componente A-Frame
        AFRAME.components['tensorflow-contour-processor'].initializeWebcamAndCanvas()
      }
    }

    // Componente A-Frame
    AFRAME.registerComponent('tensorflow-contour-processor', {
      schema: {
        targetName: {type: 'string'},
      },

      init() {
        // Carica OpenCV.js
        this.loadOpenCV()
      },

      loadOpenCV() {
        // Aggiungi messaggio di debug
        console.log('Loading OpenCV.js...')

        // Carica OpenCV.js se non è già stato caricato
        if (!window.cv) {
          const opencvScript = document.createElement('script')
          opencvScript.src = 'https://docs.opencv.org/master/opencv.js'
          opencvScript.async = true
          opencvScript.onload = () => {
            console.log('OpenCV.js script loaded.')
          }
          opencvScript.onerror = () => {
            console.error('Failed to load OpenCV.js script.')
          }
          document.head.appendChild(opencvScript)
        } else {
          // Se OpenCV.js è già stato caricato, chiama direttamente l'inizializzazione
          console.log('OpenCV.js is already loaded.')
          onOpenCvReady()
        }
      },

      initializeWebcamAndCanvas() {
        const video = document.createElement('video')
        video.setAttribute('autoplay', '')
        document.body.appendChild(video)

        const canvas = document.createElement('canvas')
        document.body.appendChild(canvas)
        const ctx = canvas.getContext('2d')

        // Messaggio di debug
        console.log('Initializing webcam...')

        navigator.mediaDevices.getUserMedia({video: true})
          .then((stream) => {
            video.srcObject = stream
            video.onloadedmetadata = () => {
              canvas.width = video.videoWidth
              canvas.height = video.videoHeight

              // Messaggio di debug
              console.log('Webcam initialized. Video dimensions:', video.videoWidth, video.videoHeight)

              // Loop per il rilevamento
              const processFrame = () => {
                ctx.drawImage(video, 0, 0)
                const src = cv.imread(canvas)
                const dst = new cv.Mat()
                cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY)
                cv.Canny(src, dst, 50, 100)
                cv.imshow(canvas, dst)

                // Messaggi di debug
                console.log('Frame processed.')
                console.log('Source matrix shape:', src.rows, src.cols)
                console.log('Destination matrix shape:', dst.rows, dst.cols)

                src.delete()
                dst.delete()
                requestAnimationFrame(processFrame)
              }
              requestAnimationFrame(processFrame)
            }
          })
          .catch((err) => {
            console.error('Error accessing webcam:', err)
          })
      },

      remove() {
        // Pulizia
        const video = document.querySelector('video')
        const canvas = document.querySelector('canvas')

        if (video) {
          if (!video.paused) {
            video.pause()
          }
          if (video.srcObject) {
            video.srcObject.getTracks().forEach(track => track.stop())
          }
          document.body.removeChild(video)
        }

        if (canvas) {
          document.body.removeChild(canvas)
        }

        // Messaggio di debug
        console.log('Cleanup complete.')
      },
    })
    
     AFRAME.registerComponent('visibility-controller', {
      schema: {
        targetId: {type: 'string'}
      },

      init() {
        const {el} = this
        this.targetEl = document.getElementById(this.data.targetId)

        // Assicurati che il targetEl sia inizializzato
        if (!this.targetEl) {
          console.error(`Target element with id "${this.data.targetId}" not found.`)
          return
        }

        // Aggiungi eventi di visibilità
        el.addEventListener('markerFound', () => {
          this.targetEl.setAttribute('visible', 'true')
        })

        el.addEventListener('markerLost', () => {
          this.targetEl.setAttribute('visible', 'true') // Mantieni visibile anche quando il marker è perso
        })
      }
    })
    </script>
</head>
<body>
   <a-scene
      xrweb="disableWorldTracking: false; allowedDevices: any"
      tensorflow-contour-processor
      arjs
      embedded
      renderer="logarithmicDepthBuffer: true;"
      vr-mode-ui="enabled: false"
      gesture-detector
      id="scene"
    >
        <a-assets>
            <a-asset-item id="sandcastleModel" src="assets/sand-castle.glb"></a-asset-item>
        </a-assets>
    
       <a-marker
        preset="hiro"
        raycaster="objects: .clickable"
        emitevents="true"
        cursor="fuse: false; rayOrigin: mouse;"
        id="markerA"
        visibility-controller="targetId: sandcastle"
      >
            <a-entity 
                id="sandcastle" 
                gltf-model="#sandcastleModel" 
                position="0 0 0" 
                scale=".6 .6 .6" 
                class="clickable" 
                gesture-handler
                visible="true">
            </a-entity>
    </a-marker>
    <a-entity camera></a-entity>
    </a-scene>
</body>
</html>
